= AdminWebModule
Arne Vandamme
:toc: left
:sectanchors:
:module-version: 3.0.1.RELEASE
:module-name: AdminWebModule
:module-artifact: admin-web-module
:module-url: https://across.foreach.be/modules/AdminWebModule
:spring-security-module-url: https://across.foreach.be/modules/SpringSecurityModule
:bootstrap-ui-module-url: https://across.foreach.be/modules/BootstrapUiModule
:entity-module-url: https://across.foreach.be/modules/EntityModule

[copyright,verbatim]
--
Copyright (C) 2014-2017 +
[small]#Copies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically.#
--

:numbered:
== General information

=== Artifact
[source,xml,indent=0]
[subs="verbatim,quotes,attributes"]
----
	<dependencies>
		<dependency>
			<groupId>com.foreach.across.modules</groupId>
			<artifactId>{module-artifact}</artifactId>
			<version>{module-version}</version>
		</dependency>
	</dependencies>
----

=== Module dependencies

.Module dependencies
|===
|Module |Type |Description

|<<integration:acrossweb>>
|required
|Provides the web infrastructure for supporting `@AdminWebController`.

|{bootstrap-ui-module-url}[BootstrapUiModule]
|required
|Required for building the basic administration UI.

|<<integration:springsecurity>>
|required
|Provides the security infrastructure.

|<<integration:application-info>>
|optional
|Sets the _admin web title_ and _remember-me_ cookie name if not set explicitly.
|===

=== Module settings

All properties start with the *adminWebModule.* prefix.

|===
|Property |Type |Description |Default

|root-path
|`String`
|Root path for all admin web controllers.  All mappings will be relative to this path.
|/admin

|dashboard
|`String`
|Path within the admin web context for the initial dashboard.
|/

|title
|`String`
|Name of the application to be shown in the administration UI.
|

|access-permissions
|`String[]`
|Set of permissions that grant access to the administration interface.
|access administration

|locale.default-locale
|`Locale`
|Default locale that should explicitly be set when accessing the administration interface if no specific locale selected.
|`Locale.US`

|locale.options
|`List<Locale>`
|List of locales that can be selected on the login page.
|`Collections.emptyList()`

|login.template
|`String`
|View template for the login page.
|th/adminweb/login

|login.rememberMe.enabled
|`Boolean`
|Should remember me be enabled (will only be the case if a key is also configured).
|`true`

|login.rememberMe.key
|`String`
|Key used for creating the remember me cookie.
|

|login.rememberMe.cookie
|`String`
|Name of the remember-me cookie.
|rm-admin-web

|login.rememberMe.tokenValiditySeconds
|`Integer`
|Number of seconds a remember me token should be valid.
|_30 days_

|===

== What's new in this version?
:numbered!:
=== 3.0.1.RELEASE

* `EntityAdminMenu` and `EntityAdminMenuEvent` have been deprecated and will be removed in the future
** these classes were almost solely used in the context of link:{entity-module-url}[EntityModule] and did not belong in AdminWebModule

=== 2.1.1.RELEASE

* Removed deprecated icon set from package and switched to new Across logo

=== 2.1.0.RELEASE

* Improved styling of the default layout
** Use of icons for Home breadcrumb, Developer tools and User context section
** http://fontawesome.io/[FontAwesome icon set] is added to the default resources
* The `AdminWebLayoutTemplate` now allows full <<customizing-nav-sections,customization of the navigational components>>
* Dismissible alerts are now converted to <<toastr-notifications,temporary Toastr notifications>> instead in order to take up less visual space
* CSRF protection now uses the `CookieCsrfTokenRepository` by default and no longer forces session creation
* the default AdminWebModule javascript has been <<adminweb-javascript,extended to expose the root path of admin section as well as static resources>>
* Bugfixes:
** styling issues with top and left menu on mobile

=== 2.0.0.RELEASE

* AdminWebModule now depends on {bootstrap-ui-module-url}[BootstrapUiModule]
* the login page now provides an attribute *isLoginPage* that is accessible in the global template
* added the <<page-content-structure,`PageContentStructure` with corresponding template>> to facilitate layouting admin pages

=== 1.1.1.RELEASE

* all settings are now configurable through properties with Spring configuration metadata support
* login template now uses the `isRememberMeEnabled` attribute to determine if the remember-me checkbox should be shown
** this is a *breaking change* for custom templates
* a <<developer-tools,Developer tools>> menu section gets created if development mode is active

=== 1.1.0.RELEASE
Initial public release available on http://search.maven.org/[Maven central].

:numbered:
== About the AdminWebModule
{module-name} provides infrastructure for building an secured administration section in your site.
All `@AdminWebController` beans will be mapped behind the admin web root path and will have the security rules applied.

Unless otherwise specified, the default admin web template will be applied for those controllers.
The default template is built on Bootstrap and JQuery and builds a menu structure that controllers can hook into via the `AdminMenuEvent`.

=== Remember me configuration
You can easily enable remember me support for the administration ui by setting the correct properties.  By default
the `TokenBasedRememberMeServices` are used, meaning the user password is encoded into the cookie value.  When using a
local memory database during development this can be unhandy when users get reinstalled upon application start.  If
the user password is also encoded using a random encoder (the default when using the `UserModule`) the remember me
cookies will not work after a restart.  The solution for this to configure either a `NoOpPasswordEncoder.getInstance()`
or a fixed password encoder in local development mode.

== Integration with other modules

[[integration:acrossweb]]
=== AcrossWebModule
Admin web creates its own `PrefixingRequestMappingHandlerMapping` that picks up all `@AdminWebController` and will prefix all request mappings with the root path of the admin web module.

Provide an `AdminWebConfigurerAdapter` if you want to register interceptors that should only be applied to the admin web controllers.

[[integration:springsecurity]]
=== SpringSecurityModule
By default `AdminWebModule` adds a `SpringWebSecurityConfigurerAdapter` with default rules for all requests under the admin web root.
If you wish to modify the default security rules, you must provide your own `SpringWebSecurityConfigurerAdapter` that is positioned before the default `AdminWebSecurityConfiguration` instance.

If you create a new `SpringWebSecurityConfigurerAdapater` you will need to scope it correctly to the admin web root path and provide all rules including things like login/logout and remember me.
If you are interested more in extending the default configuration, you can extend `AdminWebSecurityConfiguration` and override the `customizeAdminWebSecurity` adapter method.

.Example of disabling security headers on admin web
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
/**
 * Create a custom security configurer that extends from the
 * default AdminWebSecurityConfiguration but disables all
 * security headers.
 *
 * The @OrderInModule annotation will ensure that this
 * configurer will be positioned before the default configuration
 * once we add it to the AdminWebModule context.
 */
@Configuration
@OrderInModule(Ordered.HIGHEST_PRECEDENCE)
public class DisableAdminWebSecurityHeaders extends AdminWebSecurityConfiguration
{
	@Override
	protected void customizeAdminWebSecurity( HttpSecurity http ) throws Exception {
		http.headers().disable();
	}
}

...

// Add the custom security configuration to the AdminWebModule
AdminWebModule adminWebModule = new AdminWebModule();
adminWebModule.addApplicationContextConfigurer( DisableAdminWebSecurityHeaders.class );
----

[[integration:application-info]]
=== ApplicationInfoModule
If the `ApplicationInfoModule` is present in the context, the configured application information will be used
to set the default remember-me cookie name (based on the `ApplicationInfo.getApplicationId()`) and application title for
 the administration interface (based on the `ApplicationInfo.getApplicationName()` property).use DebugWebConfigurerAdapter to add interceptors only to debug web

== Registering additional interceptors
Additional interceptors for admin controllers can easily be registered by providing an `AdminWebConfigurerAdapter` bean.

== Permissions
By default, access to the administration interface is restricted to users having the *access administration* permission.
The allowed permissions can be specified by setting the *adminWebModule.access-permissions* property.

== Customizing the look and feel
=== Default template
All admin web controllers will use a default template named *adminWeb*.
You can customize which template to use by modifying the `WebTemplateRegistry` bean named *adminWebTemplateRegistry*.
You can either change the default template or simply replace the instance registered as *adminWeb*.

WARNING: The login page uses the same default template as all other admin web controllers.
This means the template should take both authorized and non-authorized authentications into account.

The default template is an implementation of `AdminWebLayoutTemplate`.
If you only want a custom view template file (eg. Thymeleaf) you can reuse the `AdminWebLayoutTemplate` class and create a new bean with custom name and template file.
The default web resources and page structure (menus) will still be created.

=== Login page
The default login page can be customized by setting the property *adminWebModule.login.template* to the Thymeleaf template you wish to render.
The login controller provides the following model attributes that can be used to customize the template:

|===

|Attribute |Type |Description

|*isLoginPage*
|`Boolean`
|Always `true`.
This attribute can be used in the wrapping template to determine if the login page is being requested.

|*isRememberMeEnabled*
|`Boolean`
|Can be used to determine if a remember me checkbox should be rendered.

|*localeOptions*
|`List<Locale>`
|Lists the different locale options that should be offered on the login page.

|===

== Building an administration UI
=== Registering admin controllers
{module-name} will scan for all beans annoted with `@AdminWebController`.
This is a replacement for the default `@Controller` annotation and marks the beans as controllers that should run under the {module-name} root path.

All request mappings that the controller declares will be prefixed with the admin root path, and will be secured behind it.
The default admin web template will be applied to the controller unless it explicitly declares a `@Template` annotation.

NOTE: `@AdminWebController` also declared a Spring condition.
Beans annotated with `@AdminWebController` will only get created if {module-name} is present.

The following code snippet illustrates creating a simple admin controller:

.Example creating a custom admin web controller
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
@AdminWebController
@RequestMapping("/demo")
public class DemoAdminWebController
{
	@RequestMapping("/page")
	public String renderPage( Model model ) {
	    model.addAttribute( "message", "Hello!" );
	    return "th/myModule/admin/page";
	}
}
----

With the default settings, the controller in the example would be available as _/admin/demo/page.

=== Linking to other admin controllers
Because admin controllers have no knowledge of the base prefix, care should be taken to use the `WebAppPathResolver` with the correct prefix for generating the right links.

There are 3 ways to do this:

* using the *adminWeb* prefix in the `WebAppPathResolver` bean: `webapp.path("@adminWeb:/demo/page")`
* using the *adminWeb* prefix directly in any Thymeleaf url: `th:href="@{@adminWeb:/demo/page}"`
* using the `AdminWeb` bean to generate paths or redirect: `adminWeb.redirect("/demo/page")`

NOTE: {module-name} registers the *adminWeb* link prefix that represents the admin web root path.

[[customizing-nav-sections]]
=== Customizing the nav sections
The default `AdminWebLayoutTemplate` builds a single `AdminMenu` that is supposed to hold all items that make up the UI nav structures.
The same `AdminMenu` is used to render the different nav components on the layout:

* top navigation
** the top navigation actually consists of a left-hand (_navbar_) and right-hand (_navbar-right_) side
* left-hand navigation
* breadcrumb

All nav structures are built using a `NavComponentBuilder` from the {bootstrap-ui-module-url}[BootstrapUiModule] and support all options like HTML attributes, icons and custom `ViewElements`.

==== Default AdminMenu structure
By default the `AdminMenu` contains 3 items:

* the root item (*/*)
* the user context item group (*/user-context*)
** this group is rendered only on the right-hand side of the top navigation
* the logout link as member of the user-context (*/user-context/logout*)

These default items can be customized using the `AdminMenuEvent`.

.Example replacing the default user-context icon by a user profile picture
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
private ViewElementBuilder myProfilePictureViewElementBuilder;

@EventListener
public void addUserProfilePicture( AdminMenuEvent adminMenuEvent ) {
	adminMenuEvent.builder()
	              .group( DefaultAdminMenuRegistrar.PATH )
	              .attribute( NavComponentBuilder.ATTR_ICON, myProfilePictureViewElementBuilder );
}
----

==== Adding a page to the main nav section
If you want to add a page to the main navigation section of admin web, you can do so by simply registering it in the `AdminMenu`.
The easiest way to do that is by intercepting the `AdminMenuEvent`.

.Example creating a custom admin web controller
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
@EventListener
public void registerMenuItem( AdminMenuEvent adminMenuEvent ) {
	adminMenuEvent.builder()
	              .group( "/group", "Demo pages" ).and()
	              .item( "/group/page", "My demo page", "/demo/page" );
}
----

NOTE: Relative urls added to the `AdminMenuEvent` will be considered admin web relative, and will get prefixed with the admin web root path.
If you want to avoid this, either use absolute urls, add a specific prefix or begin them with an exclamation mark (!).

==== Specifying a nav section
By default any item will be added both to the top navigation and the left-hand navigation.
You can limit the sections an item should be added to by adding a value for *adminMenu:position* attribute on a `Menu`.

The value can be either a `String` or a `String[]`.

Possible positions are:

* _navbar_: render the item in the top (left) navbar
* _navbar-right_: render the item in the top right navbar
* _sidebar_: render the item in the left sidebar

.Example adding a menu item to the top right and sidebar navigation
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
@EventListener
public void registerMenuItem( AdminMenuEvent adminMenuEvent ) {
    adminMenuEvent.builder()
                .group( "/tools", "Tools" )
                .attribute(
                    AdminMenu.ATTR_NAV_POSITION,
                    new String[] { AdminWebLayoutTemplate.NAVBAR_RIGHT, AdminWebLayoutTemplate.SIDEBAR }
                );
}
----

==== Excluding an item from the breadcrumb
By default all `Menu` items will be included in the breadcrumb.
Explicitly excluding an item can be done by setting the *adminMenu:breadcrumb* attribute to `false`.

.Example excluding a menu item from the breadcrumb
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
@EventListener
public void registerMenuItem( AdminMenuEvent adminMenuEvent ) {
    adminMenuEvent.builder()
                .group( "/tools", "Tools" )
                .attribute( AdminMenu.ATTR_BREADCRUMB, false );
}
----

[[page-content-structure]]
=== Default page structures
When creating an admin web page you can use the `PageContentStructure` to help you build a reliable layout.
The `PageContentStructure` is a `ViewElement` that represents the different sections on a page:

* _header_ with the _page title_ and optionally _page title sub text_
* _feedback_ section below the header but before the other page content
* _nav_ section meant for the in-page navigation (for example tabs)
* _body_ section holding the main content
* _footer_ section at the bottom

`PageContentStructure` can be autowired as a request-scoped bean.
If you then use the default template `PageContentStructure.TEMPLATE` this will render the entire page.
This requires you to add all content as `ViewElement` components, but of course you can still specify one or more of the `ViewElement` values to use a custom template for rendering.

.Example using the default page structure
[source,java,indent=0]
[subs="verbatim,attributes"]
----
@Autowired
private PageContentStructure page;

@RequestMapping("/page")
public String pageContent( ViewElementBuilderContext builderContext ) {

    // Render a tab layout
    page.setRenderAsTabs( true );

    // Manually create a menu structure
    Menu menu = new PathBasedMenuBuilder()
        .item( "/one", "One", "#" ).order( 1 ).and()
        .group( "/advanced", "Advanced settings" )
        .order( 2 )
        .attribute( "html:class", "pull-right" )
        .attribute( NavComponentBuilder.ATTR_ICON_ONLY, true )
        .and()
        .item( "/advanced/trash", "Move to trash", "#" )
        .attribute( NavComponentBuilder.ATTR_ICON, new GlyphIcon( GlyphIcon.TRASH ) )
        .and()
        .build();
    menu.sort();

    page.setPageTitle( "Some page title..." );
    page.addToPageTitleSubText( new GlyphIcon( GlyphIcon.ALERT ) );

    // Convert our menu to a tab nav
    page.addToNav( bootstrapUiComponentFactory.nav( menu ).tabs().build( builderContext ) );
    page.addToFeedback(
        bootstrapUiFactory.alert().danger().dismissible().text( "Hello!" )
                            .build( builderContext )
    );

    page.addChild( TextViewElement.text( "Some body content..." ) );

    return PageContentStructure.TEMPLATE;
}
----

If you do not want to use the request scoped `PageContentStructure`, you can always manually create an instance.
For the default template to work, it requires the structure to be available on the model as the default *pageContentStructure* attribute.

.Example using a custom page structure
[source,java,indent=0]
[subs="verbatim,attributes"]
----
@RequestMapping("/page")
public String pageContent( @ModelAttribute PageContentStructure page ) {
    ...

    return PageContentStructure.TEMPLATE;
}
----

Instead of using the default template `PageContentStructure.TEMPLATE`, you can always use your own page template and simply render some of the `ViewElement` properties of the `PageContentStructure` where and when you want them.

[[developer-tools]]
=== Developer tools section
If development mode is active on the Across context, a menu group titled *Developer tools* will get created.
This allows other modules to register development only resources in the administration UI.

The path of the menu group is */ax/developer*.

.Example development controller that only gets created if development mode is active
[source,java,indent=0]
[subs="verbatim,attributes"]
----
@AdminWebController
@ConditionalOnDevelopmentMode
@RequiredArgsConstructor
public class DevToolsController
{
	private final PageContentStructure pageContentStructure;

	@EventListener
	void registerDeveloperToolsItem( AdminMenuEvent menuEvent ) {
		menuEvent.builder().item( DeveloperToolsMenuRegistrar.PATH + "/test", "Test controller" );
	}

	@GetMapping("/ax/developer/test")
	public String test() {
		pageContentStructure.setPageTitle( "Test developer tools page..." );
		return PageContentStructure.TEMPLATE;
	}
}
----

[[adminweb-javascript]]
=== AdminWebModule javascript
AdminWebModule registers some Javascript and exposes an `AdminWebModule` and `AcrossWebModule` global variable.
These can be used to configure some of the default client-side behaviour settings.

The necessary web resources are registered automatically by the `AdminWebLayoutTemplate`.
If you have a custom template implementation, you probably want to register the `AdminWebWebResources` manually.

==== Client-side paths
A couple of web application paths are exposed as global javascript variables:

[cols="1,4",options="header"]
|===
|Variable
|Content

|`AcrossWebModule.resourcePath`
|Holds the base path for exposed web resources.
Equivalent of `@resource:/` in a server-side link.

|`AcrossWebModule.staticPath`
|Holds the base path for the default static resources.
Equivalent of `@static:/` in a server-side link.

|`AdminWebModule.rootPath`
|Holds the base path onto which AdminWeb UI has been mapped.
Equivalent of `@adminWeb:/` in a server-side link.

|===

NOTE: The last slash (/) token will always be stripped from the exposed paths.
Example creating a custom path: `AdminWebModule.rootPath + '/my-controller'`.

[[toastr-notifications]]
==== Toastr notifications
By default AdminWebModule will convert all Bootstrap dismissible alerts into http://codeseven.github.io/toastr/[Toastr notifications].
If you do not want to use Toastr at all, simply removing the javascript should be sufficient.
If you only want to disable dismissible alert conversion, you can do so by updating the `AdminWebModule` javascript property:

.Disabling Toastr notifications
[source,html,indent=0]
[subs="verbatim,attributes"]
----
<script type="text/javascript">
// Disable Toastr notifications - ensure this block is executed after initial admin-web-module.js
AdminWebModule.useToastrNotifications = false;
</script>
----
